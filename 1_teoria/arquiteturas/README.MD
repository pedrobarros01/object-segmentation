# Arquiteturas de Deep Learning para segmenta√ß√£o
## CNN (Redes Neurais Convolucionais)
√â uma arquitetura de deep learning que utilizada de camadas convolucionais para aplicar filtros em imagens e  assim extrair caracterist√≠cas dessas. Ela √© composta de m√∫ltiplas camadas, incluindo camadas convolucionais, camadas de pooling e camadas totalmente conectadas. Assim, as camadas s√£o divididas em:
1. Camadas Convulocionais: S√£o camdas que realizam convolu√ß√µes na imagem de entrada, aplicando filtros/kernels que ir√£o extrair caracteristicas da entrada, como borda, textura, cor e padr√µes mais complexos. Opera√ß√µes convolucionais ajudam a preservar as rela√ß√µes espaciais entre pixels.

![conv](../images/convolucao2.gif)

2. Camadas de Pooling: Camadas de pooling acabam reduzindo a amostragem das dimens√µes espaciais da imagem de entrada, reduzindo assim a complexidade computacional que o treino oferece junto com os parametros da rede

![pooling](../images/pooling.gif)

3. Fun√ß√µes de ativa√ß√£o: S√£o fun√ß√µes matem√°ticas que introduzem a n√£o-linearidade do modelo, fazendo com que o modelo aprenda padr√µes mais complexos dos dados.

4. Camadas totalmente conectadas: S√£o as camadas que fazem as previs√µes necess√°rias com base no aprendizado das outras camadas, ou seja, √© onde o modelo ira classifica/detectar/segmentar um objeto na imagem.

![cnn](../images/Convolutional-Neural-Networks-CNN-1.jpeg)

## R-CNN (Region-based Convolutional Neural Network)
As R-CNN utilizam da CNN para exercer as suas fun√ß√µes de classificar objetos mas com uma l√≥gica a mais: Elas dividem a imagem em diversas regi√µes potenciais como entrada para uma CNN comum.
"O R-CNN come√ßa dividindo a imagem de entrada em v√°rias regi√µes ou sub-regi√µes. Essas regi√µes s√£o chamadas de "propostas de regi√£o" ou "candidatos de regi√£o". A etapa de proposta de regi√£o √© respons√°vel por gerar um conjunto de regi√µes potenciais na imagem que provavelmente cont√™m objetos." (roboflow)

![rcnn](../images/rcnn.png)

Essa divis√£o na verdade √© feita por uma t√©cnica externa ao modelo, que pode ser a Busca seletiva ou algum tipo de detec√ß√£o de bordas. Entretanto a maioria das R-CNNs utilizam da Busca Seletiva, essa funciona mesclando ou dividindo a imagem em diversos segmentos com base em alguma indica√ß√µes: cor, textura, forma. Para criar um conjunto diversisificado de regi√µes e assim acaba enviando essas regi√µes na entrada da rede para exercer a classifica√ß√£o.

![rcnn](../images/busca-seletiva.png)

## Fast R-CNN
Em vez de enviar regi√µes na entrada, s√£o enviados a imagem e as regi√µes, entretandto cada regi√£o passa por uma camada de pooling para formar um conjunto de caracteristicas do mesmo tamanho, isso garante que as regi√µes contenham o mesmo tamanho e no final dessa camada de pooling √© pegado esses mapas de caracteristicas e agrupados em um unico vetor de caracteristicas e com isso a rede cont√©m a 2 sa√≠das: a probabilidade de ser o objeto e a caixa delimetadora.

![fastrcnn](../images/fast-r-cnn.png)

A camada de RoI pooling utiliza max pooling para converter as caracter√≠sticas dentro de qualquer regi√£o de interesse v√°lida em um pequeno mapa de caracter√≠sticas com uma extens√£o espacial fixa de H√óW, por exemplo 7x7, onde ùêª e ùëä s√£o hiperpar√¢metros da camada independentes de qualquer RoI espec√≠fico.

O RoI max pooling funciona dividindo a janela RoI de ‚Ñé√óùë§ em uma grade de sub-janelas de ùêª √ó ùëä com tamanho aproximado de ‚Ñé/ùêª √ó ùë§/ùëä. Em seguida, √© aplicado o max pooling aos valores de cada sub-janela, armazenando o valor m√°ximo na c√©lula correspondente da grade de sa√≠da. O pooling √© realizado de forma independente para cada canal do mapa de caracter√≠sticas, como no max pooling padr√£o.

O Faster R-CNN compartilha computa√ß√µes (ou seja, c√°lculos de camada convolucional) em todas as propostas (ou seja, ROIs) em vez de fazer os c√°lculos para cada proposta independentemente. 

## Faster R-CNN
Esse modelo cont√©m a atualiza√ß√£o de retirar a dependencia da busca seletiva e adiciona uma rede em paralelo chamada de Region Proposal Network, que agora pega o mapa de caracteristicas extraidos e vai definindo regi√µes de interesse da imagem com base em ancoras(diversos bounding boxes espalhados que ao juntar a interse√ß√£o deles √© apresentado a caixa que mais define o objetp).

![fastrcnn](../images/faster-r-cnn.png)


![ancora](../images/ancoras.png)


## Mask R-CNN
Utilizando a arquitetura da Faster R-CNN com algumas melhorias, tal como a Mask Head e as FPNS. Mas para isso √© necess√°rio detalhar a arquitetura dessa rede
### Redes Backbone
Basicamente a Backbone √© uma rede neural convulocional pr√© treinada, onde ela processa a imagem de entrada e extrai caracteristicas de alto n√≠vel. Assim, a FPN (Feature Pyramid Network) √© utilizada para criar uma pir√¢mide de caracteristicas baseadas em diversas dimens√µes especificas. Essa pir√¢mide inclui caracteristicas com resolu√ß√µes espaciais variadas, de recursos de alta resolu√ß√£o com informa√ß√µes sem√¢nticas ricas a recursos de baixa resolu√ß√£o com detalhes espaciais mais precisos.

![fpn](../images/fpn.png)

A FPN funciona nas seguintes etapas:

1. Extra√ß√£o de recursos : a rede de backbone extrai recursos de alto n√≠vel da imagem de entrada.

2. Fus√£o de Recursos : FPN cria conex√µes entre diferentes n√≠veis da rede de backbone para criar um caminho de cima para baixo. Esse caminho de cima para baixo combina informa√ß√µes sem√¢nticas de alto n√≠vel com mapas de recursos de n√≠vel inferior, permitindo que o modelo reutilize recursos em diferentes escalas.

3. Pir√¢mide de Caracter√≠stica : O processo de fus√£o gera uma pir√¢mide de fei√ß√µes multi-escala, onde cada n√≠vel da pir√¢mide corresponde a diferentes resolu√ß√µes de fei√ß√µes. O n√≠vel superior da pir√¢mide cont√©m as fei√ß√µes de maior resolu√ß√£o, enquanto o n√≠vel inferior cont√©m as fei√ß√µes de menor resolu√ß√£o.

A Mask Utiliza da RPN para dividir a imagem em regioes menores

### ROIAlign
O ROIAlign desempenha um papel crucial na extra√ß√£o precisa de caracteristicas do mapa de caracteristicas de entrada para cada proposta de regi√£o, garantindo segmenta√ß√£o precisa por pixel em tarefas de segmenta√ß√£o de inst√¢ncia.

O prop√≥sito principal do ROIAlign √© alinhar as caracteristicas dentro de uma regi√£o de interesse (ROI) com a grade espacial do mapa de recursos de sa√≠da. Esse alinhamento √© crucial para evitar perda de informa√ß√µes que pode ocorrer ao quantizar as coordenadas espaciais do ROI para o inteiro mais pr√≥ximo (como feito no ROI pooling).

![interpolacao](../images/interpolacao.png)

Ela utiliza da interpola√ß√£o bilinear para alinhar com precis√£o as ROIS com a grid do mapa de caracteristicas. Assim nao tendo perda de informa√ß√£o importante como a ROIPolling faz.

### Mask Head
Seu funcionamento esta em dizer pixel a pixel se pertence a algum objeto ou n√£o, ela recebe as caracteristicas alinhadas com a ROI e disso consegue produzir uma mascara binaria e gerando assim a mascara de segmenta√ß√£o. Ela utiliza de camadas convulocionais  e de upsampling  para assim gerar mascaras em escala pedida com grandes detalhes.

![mask](../images/mask-head.png)


Assim a Mask R-CNN cont√©m essa arquitetura:

![maskrcnn](../images/mask-r-cnn.png)

## U-NET
Basicamente a U-NET vai conter camadas de convolu√ß√£o que ir√£o diminuir a resolu√ß√£o espacial e capturar caracteristicas mais profundas. Este caminho de contrata√ß√£o √© semelhante √†s camadas de feedforward em outras redes neurais convolucionais. Por outro lado, o caminho expansivo trabalha na decodifica√ß√£o dos dados codificados e na localiza√ß√£o dos recursos, mantendo a resolu√ß√£o espacial da entrada. As camadas decodificadoras no caminho expansivo aumentam a amostragem dos mapas de recursos, enquanto tamb√©m realizam opera√ß√µes convolucionais.

As conex√µes de salto do caminho de contrata√ß√£o ajudam a preservar as informa√ß√µes espaciais perdidas no caminho de contrata√ß√£o, o que ajuda as camadas decodificadoras a localizar os recursos com mais precis√£o.

![unet](../images/unet.png)

A Figura 1 demonstra como a rede U-Net transforma uma imagem de entrada em tons de cinza de tamanho 572√ó572√ó1 em um mapa de sa√≠da segmentado bin√°rio de dimens√£o 388√ó388√ó2. √â importante observar que o tamanho da sa√≠da √© inferior ao da entrada, uma vez que n√£o est√° sendo utilizado preenchimento. Entretanto, ao aplicarmos preenchimento, podemos preservar o tamanho original da entrada. Durante a fase de contra√ß√£o, a imagem de entrada √© progressivamente reduzida em altura e largura, enquanto o n√∫mero de canais aumenta. Esse crescimento no n√∫mero de canais permite que a rede capture caracter√≠sticas de alto n√≠vel √† medida que avan√ßa pela arquitetura. No ponto de estrangulamento, uma opera√ß√£o de convolu√ß√£o final √© executada para produzir um mapa de recursos de dimens√£o 30√ó30√ó1024. O caminho expansivo, ent√£o, utiliza esse mapa de recursos do gargalo para restaurar a imagem ao tamanho da entrada original. Isso √© realizado por meio de camadas de upsampling, que elevam a resolu√ß√£o espacial do mapa de recursos, enquanto diminuem o n√∫mero de canais. As conex√µes de salto do caminho de contra√ß√£o s√£o empregadas para auxiliar as camadas do decodificador a localizar e aprimorar as caracter√≠sticas na imagem. Por fim, cada pixel no mapa de sa√≠da corresponde a um r√≥tulo que representa um objeto ou classe espec√≠fica na imagem de entrada. Nesse contexto, o mapa de sa√≠da √© um mapa de segmenta√ß√£o bin√°ria, onde cada pixel indica uma regi√£o de primeiro ou segundo plano.